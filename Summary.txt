1 Min Stack:
	A. 数组初始化大小：
		若太大：runtime error
		若太小：可能Wrong error
		此题中取：100000 * 2 * 4B = 200 KB
	
2 Tow Sum:
	A. struct 可以声明在类内部
	
3 Add tow numbers:
	A. 用new申请的指针，如果不用，一定要delete掉
	B. 链表中尽量应用已存在节点，new，delete操作比较耗时间
	C. 超时可能是死循环
	D. delete会把相应内存释放掉，不管是不是还存在其他的引用，若存在其他引用，则该应用也无效
	
4 Number of 1 bits
	赋值操作比较耗时间
	
		i << j 	//比较快
		i <<= 1;
		
5 Combination 
	A. 递归分为单递归以及多分支递归，单递归单线直接调用即可。
	   多分支递归一般用For循环控制递归的分支数（广度）
	B. 排列组合建模（本质关系的映射）——集合的存储实现之一就是：位向量=》解决特定问题的时候，希望自己能够有一定的方法论作为指导：先去用数据结构建模
		栈+队列
		位向量（从另一个角度去构造解答树）：
			类似二进制，只是具体的操作方式不同，存贮一致。
		解答树：
			如果某问题的解可以有多个步骤得到，而每个步骤都有若干种选择（这些候选方案集可能依赖于先前做出的选择），且可以用枚举递归法实现，则它的工作方式可以用解答树来实现。
		位向量法二
			表示：0,1可以表示存不存在这个元素
			集合的操作：常见的集合运算都可以用位运算实现

6 Factorial Trailing Zeros
	A. 面对任何问题，纸笔先行，不要想当然的看问题。积极一点，认真去分析、思考，一点点搞清事实，从问题出发找解决思路，不要总是用经验套用，应该在	   分析问题的基础之上去调用经验这种工具，不应本末倒置。
	B. 本题分析的关键是什么时候产生0：任何一个数都可以表示为所有素数n次幂的乘积 =》只有2 & 5的乘积才能产生0！
	C. 刚开始，其实就把问题想复杂了，从而没有静下心来仔细思考。

7  Divide Two Integers
	A. TLE：在时间复杂度一定的情况下，注意检查循环是否有infinit loop。本题中就是因为左移运算定义为int，从而造成失误。
	B. 编译器大多不支持正负数数量对称。

8 Find Minimum in Rotated Sorted Array
	A. 就是这样，先有个整体的思考思路，然后沉下心来做。

9 Reverse Linked List II
	A. 链表要注意返回的指针，避免想当然：引用同一地址的两个变量各自维护自己的值。

10 3Sum:
	A. 纸笔先行才能发现具体的规律，仔细一点，把所有元素都列出来，更容易发现规律：如何快速找到满足条件的两个数：O(n^2) -> O(n); 借助排序。

11 Reverse Integer
	A. 在大多数编译器中整数的正负个数不是对称的：
		
		long long lx = x;
        lx = abs(lx);

        与

        long long lx = abs(x) 不是等价的。因为当x是最小值的时候abs取出来的值是不变的
        先扩大后再取绝对值！！！！

12 Maximum Subarray
	A. 拿case进行找规律，找到该有的方案！！！！！纸笔先行！

13 Binary Search Tree Iterator
	A. 用大小为O(high)的栈可以中序遍历二叉搜索树！！！其实就是中序遍历的递归栈模拟转化！！！！

14 Set Matrix Zeroes
	A. 静下心来用心去分析，从所求出发逐步求解：How to solve it 的实践！
	B. 常数空间的话，第一可以考虑是不是固定数量的几个变量能搞定；否则可以考虑是不是问题本身已经提供了足够的空间。这道题属于后者，就是利用矩阵的第一行和第一列来作为辅助空间使用。不用开辟新的存储空间。

15 Insertion Sort List
	A. 在确定时间复杂度可以通过时，若TLE，则可以调整部分代码实现以提高速度（剪枝、短路等）

16 Text Justification
	A. 一定要把思路搞清楚，不可模棱两可，确定之后积极自信的coding，切忌犹豫！

17 Path Sum II
	A. 注意树的递归访问与迭代访问的区别：
		递归，每一节点访问结束，该节点立马退栈，所以在前序中续中，不要考虑从哪个节点返回，但是这样以来如果要求记录父节点的话，因为访问的节点已经退栈，所以就无从下手；而递归将所有的信息都保存在递归调用栈中，所以若模拟实现的话，迭代中要有更多的控件记录信息！！！！

18 Symmetric Tree
	A. 思路：先序 + 中序可以唯一确定一棵树，所以如果中心对称，则其左右对换之后的这两种遍历顺序完全一致！递归算法实现，比较慢！！！

19 Binary Tree Postorder Traversal
	A. stack的top（）函数返回的是栈顶元素的副本，不是引用，所以在后序遍历的过程中一定要先退出栈，再压入！

20 Minimum Depth of Binary Tree
	A. 结合第17条，必须在检查当前节点的时候，进行节点处理（看是不是叶子节点），而不是想当然的在两次递归完成后才是叶子节点…………………………！！！！！！！！

21 Compare Version Numbers
	A. C++标准中因为数组不是一种类型，所以函数不能返回数组，三种处理方式：
		1）返回指向数组的指针
		2）返回结构体，把数组包裹在其中
		3）引用参数传递
	B. C++中用sstream库进行string与各种类型之间的安全转换！！

22 Search for a Range
	A. 二分查找，注意边界条件的判断！就是low == high的情况如何处理！！！