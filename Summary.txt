1 Min Stack:
	A. 数组初始化大小：
		若太大：runtime error
		若太小：可能Wrong error
		此题中取：100000 * 2 * 4B = 200 KB
	
2 Tow Sum:
	A. struct 可以声明在类内部
	
3 Add tow numbers:
	A. 用new申请的指针，如果不用，一定要delete掉
	B. 链表中尽量应用已存在节点，new，delete操作比较耗时间
	C. 超时可能是死循环
	D. delete会把相应内存释放掉，不管是不是还存在其他的引用，若存在其他引用，则该应用也无效
	
4 Number of 1 bits
	赋值操作比较耗时间
	
		i << j 	//比较快
		i <<= 1;
		
5 Combination 
	A. 递归分为单递归以及多分支递归，单递归单线直接调用即可。
	   多分支递归一般用For循环控制递归的分支数（广度）
	B. 排列组合建模（本质关系的映射）——集合的存储实现之一就是：位向量=》解决特定问题的时候，希望自己能够有一定的方法论作为指导：先去用数据结构建模
		栈+队列
		位向量（从另一个角度去构造解答树）：
			类似二进制，只是具体的操作方式不同，存贮一致。
		解答树：
			如果某问题的解可以有多个步骤得到，而每个步骤都有若干种选择（这些候选方案集可能依赖于先前做出的选择），且可以用枚举递归法实现，则它的工作方式可以用解答树来实现。
		位向量法二
			表示：0,1可以表示存不存在这个元素
			集合的操作：常见的集合运算都可以用位运算实现

6 Factorial Trailing Zeros
	A. 面对任何问题，纸笔先行，不要想当然的看问题。积极一点，认真去分析、思考，一点点搞清事实，从问题出发找解决思路，不要总是用经验套用，应该在	   分析问题的基础之上去调用经验这种工具，不应本末倒置。
	B. 本题分析的关键是什么时候产生0：任何一个数都可以表示为所有素数n次幂的乘积 =》只有2 & 5的乘积才能产生0！
	C. 刚开始，其实就把问题想复杂了，从而没有静下心来仔细思考。

7  Divide Two Integers
	A. TLE：在时间复杂度一定的情况下，注意检查循环是否有infinit loop。本题中就是因为左移运算定义为int，从而造成失误。
	B. 编译器大多不支持正负数数量对称。

8 Find Minimum in Rotated Sorted Array
	A. 就是这样，先有个整体的思考思路，然后沉下心来做。

9 Reverse Linked List II
	A. 链表要注意返回的指针，避免想当然：引用同一地址的两个变量各自维护自己的值。

10 3Sum:
	A. 纸笔先行才能发现具体的规律，仔细一点，把所有元素都列出来，更容易发现规律：如何快速找到满足条件的两个数：O(n^2) -> O(n); 借助排序。

11 Reverse Integer
	A. 在大多数编译器中整数的正负个数不是对称的：
		
		long long lx = x;
        lx = abs(lx);

        与

        long long lx = abs(x) 不是等价的。因为当x是最小值的时候abs取出来的值是不变的
        先扩大后再取绝对值！！！！

12 Maximum Subarray
	A. 拿case进行找规律，找到该有的方案！！！！！纸笔先行！

13 Binary Search Tree Iterator
	A. 用大小为O(high)的栈可以中序遍历二叉搜索树！！！其实就是中序遍历的递归栈模拟转化！！！！

14 Set Matrix Zeroes
	A. 静下心来用心去分析，从所求出发逐步求解：How to solve it 的实践！
	B. 常数空间的话，第一可以考虑是不是固定数量的几个变量能搞定；否则可以考虑是不是问题本身已经提供了足够的空间。这道题属于后者，就是利用矩阵的第一行和第一列来作为辅助空间使用。不用开辟新的存储空间。

15 Insertion Sort List
	A. 在确定时间复杂度可以通过时，若TLE，则可以调整部分代码实现以提高速度（剪枝、短路等）

16 Text Justification
	A. 一定要把思路搞清楚，不可模棱两可，确定之后积极自信的coding，切忌犹豫！

17 Path Sum II
	A. 注意树的递归访问与迭代访问的区别：
		递归，每一节点访问结束，该节点立马退栈，所以在前序中续中，不要考虑从哪个节点返回，但是这样以来如果要求记录父节点的话，因为访问的节点已经退栈，所以就无从下手；而递归将所有的信息都保存在递归调用栈中，所以若模拟实现的话，迭代中要有更多的控件记录信息！！！！

18 Symmetric Tree
	A. 思路：先序 + 中序可以唯一确定一棵树，所以如果中心对称，则其左右对换之后的这两种遍历顺序完全一致！递归算法实现，比较慢！！！

19 Binary Tree Postorder Traversal
	A. stack的top（）函数返回的是栈顶元素的副本，不是引用，所以在后序遍历的过程中一定要先退出栈，再压入！

20 Minimum Depth of Binary Tree
	A. 结合第17条，必须在检查当前节点的时候，进行节点处理（看是不是叶子节点），而不是想当然的在两次递归完成后才是叶子节点…………………………！！！！！！！！

21 Compare Version Numbers
	A. C++标准中因为数组不是一种类型，所以函数不能返回数组，三种处理方式：
		1）返回指向数组的指针
		2）返回结构体，把数组包裹在其中
		3）引用参数传递
	B. C++中用sstream库进行string与各种类型之间的安全转换！！

22 Search for a Range
	A. 二分查找，注意边界条件的判断！就是low == high的情况如何处理！！！

23 Convert Sorted Array to Binary Search Tree
	A. 递归构建平衡二叉树的一种思路！！
	B. 位运算符的优先级要低于算术运算符
	C. 一定养成良好的编程习惯：变量的初始化；本例中就是因为指针变量未初始化，导致RunTime Error

24 字符串拼接尽量用+,而不是append。

25 Majority Element
	A. 可以考虑其他实现方法：充分挖掘题目隐含关系，从而实现高效算法！！！！！！！

26 Count and Say
	A. 使用sstringstream时，注意清空问题：ss.str("") + ss.clear();

27 Sort List
	A. !!!指针变量也存在引用与否的问题，如果在递归中，是一局部变量，则返回时，就会释放，所以一定要注意定义返回值保存该过程中计算结果：
		int* cal(int *a) {
			int b;
			a = *b;
			return a;
		}

		void main() {

			int *a = new int;

			cal(a);


		}
	若a计算后的值，只有在该域内有效，若偏离该域，则要定义新的变量存储该值，此时a的值并没有改变。因为参数传递过程中，是将a的变量值拷贝到了形参！！！！但是若是在函数中改变变量所指的值，则val会更新，而地址值是不变的！
	B. 归并排序中，链表可以不用辅助空间，但是顺序表需要O(n)的辅助数组。
	C. 链表中如何寻找中点！！

28 Balanced Binary Tree
	A. 递归过程分析很重要，要考虑变量如何维护：返回到上层调用函数可以用引用参数，适用于本次调用的参数依赖于下层子问题的影响。

29 Jump Game II
	A. 静下心来，用case帮助思考找充分条件！！！How to solve it! 从问题出发！！不要考虑其他的：管他叫什么，反正就是这样子！！

30 Gas Station
	A. 注意细心查找隐藏关系：前面的不行，到此为止，都不行，所以可以O(n)
	B. 搞清楚关系本质才能快速代码化！！千万不能模棱两可，去找出内在联系，然后再代码化，不能猜！！

31 Flatten Binary Tree to Linked List
	A. 递归值的记录有两种方式：
		1) 引用传递
		2）递归函数的返回值
		影响是双向的，要看自己是从父子哪个角度看： 代码leftRe->right = tmp
		因为这两种方式，都在整个可见域内
	B. 注意低吗：return leftRe :当前层就要返回当前层的！！！

32 Scramble String
	A. 基本类型、声明符、修饰符
	B. new生成数组？！
	C. dp的本质就是子问题的记录功能，以至于能够不重复计算子问题！
	D. 看问题，一定要仔细分析，找到充分条件，否则事倍功半！注意子问题的划分，可以多求子问题，但不可以少求！问题复杂的时候，一定要拿case去找联系！

33 Climbing Stairs
	A. 记得从另一角度思考问题！！！！不同的角度可以建立不同的解决问题的模型！！！！

34 Sqrt(x)
	A. 牛顿迭代法！！！注意问题的抽象建模，可以从多个角度出发！！！
	B. 亦可以有二分法！！

35 Sum Root to Leaf Numbers
	A. 递归中需要记录所有上层影响的（回溯时需要用到当层的状态），传递赋值参数记录上层即可；若全局影响的可以定义引用变量！

36 