重点题目： 140 84 


1 Min Stack:
	A. 数组初始化大小：
		若太大：runtime error
		若太小：可能Wrong error
		此题中取：100000 * 2 * 4B = 200 KB
	
2 Tow Sum:
	A. struct 可以声明在类内部
	
3 Add tow numbers:
	A. 用new申请的指针，如果不用，一定要delete掉
	B. 链表中尽量应用已存在节点，new，delete操作比较耗时间
	C. 超时可能是死循环
	D. delete会把相应内存释放掉，不管是不是还存在其他的引用，若存在其他引用，则该应用也无效
	
4 Number of 1 bits
	赋值操作比较耗时间
	
		i << j 	//比较快
		i <<= 1;
		
5 Combination 
	A. 递归分为单递归以及多分支递归，单递归单线直接调用即可。
	   多分支递归一般用For循环控制递归的分支数（广度）
	B. 排列组合建模（本质关系的映射）——集合的存储实现之一就是：位向量=》解决特定问题的时候，希望自己能够有一定的方法论作为指导：先去用数据结构建模
		栈+队列
		位向量（从另一个角度去构造解答树）：
			类似二进制，只是具体的操作方式不同，存贮一致。
		解答树：
			如果某问题的解可以有多个步骤得到，而每个步骤都有若干种选择（这些候选方案集可能依赖于先前做出的选择），且可以用枚举递归法实现，则它的工作方式可以用解答树来实现。
		位向量法二
			表示：0,1可以表示存不存在这个元素
			集合的操作：常见的集合运算都可以用位运算实现

6 Factorial Trailing Zeros
	A. 面对任何问题，纸笔先行，不要想当然的看问题。积极一点，认真去分析、思考，一点点搞清事实，从问题出发找解决思路，不要总是用经验套用，应该在	   分析问题的基础之上去调用经验这种工具，不应本末倒置。
	B. 本题分析的关键是什么时候产生0：任何一个数都可以表示为所有素数n次幂的乘积 =》只有2 & 5的乘积才能产生0！
	C. 刚开始，其实就把问题想复杂了，从而没有静下心来仔细思考。

7  Divide Two Integers
	A. TLE：在时间复杂度一定的情况下，注意检查循环是否有infinit loop。本题中就是因为左移运算定义为int，从而造成失误。
	B. 编译器大多不支持正负数数量对称。

8 Find Minimum in Rotated Sorted Array
	A. 就是这样，先有个整体的思考思路，然后沉下心来做。

9 Reverse Linked List II
	A. 链表要注意返回的指针，避免想当然：引用同一地址的两个变量各自维护自己的值。

10 3Sum:
	A. 纸笔先行才能发现具体的规律，仔细一点，把所有元素都列出来，更容易发现规律：如何快速找到满足条件的两个数：O(n^2) -> O(n); 借助排序。

11 Reverse Integer
	A. 在大多数编译器中整数的正负个数不是对称的：
		
		long long lx = x;
        lx = abs(lx);

        与

        long long lx = abs(x) 不是等价的。因为当x是最小值的时候abs取出来的值是不变的
        先扩大后再取绝对值！！！！

12 Maximum Subarray
	A. 拿case进行找规律，找到该有的方案！！！！！纸笔先行！

13 Binary Search Tree Iterator
	A. 用大小为O(high)的栈可以中序遍历二叉搜索树！！！其实就是中序遍历的递归栈模拟转化！！！！

14 Set Matrix Zeroes
	A. 静下心来用心去分析，从所求出发逐步求解：How to solve it 的实践！
	B. 常数空间的话，第一可以考虑是不是固定数量的几个变量能搞定；否则可以考虑是不是问题本身已经提供了足够的空间。这道题属于后者，就是利用矩阵的第一行和第一列来作为辅助空间使用。不用开辟新的存储空间。

15 Insertion Sort List
	A. 在确定时间复杂度可以通过时，若TLE，则可以调整部分代码实现以提高速度（剪枝、短路等）

16 Text Justification
	A. 一定要把思路搞清楚，不可模棱两可，确定之后积极自信的coding，切忌犹豫！

17 Path Sum II
	A. 注意树的递归访问与迭代访问的区别：
		递归，每一节点访问结束，该节点立马退栈，所以在前序中续中，不要考虑从哪个节点返回，但是这样以来如果要求记录父节点的话，因为访问的节点已经退栈，所以就无从下手；而递归将所有的信息都保存在递归调用栈中，所以若模拟实现的话，迭代中要有更多的控件记录信息！！！！

18 Symmetric Tree
	A. 思路：先序 + 中序可以唯一确定一棵树，所以如果中心对称，则其左右对换之后的这两种遍历顺序完全一致！递归算法实现，比较慢！！！

19 Binary Tree Postorder Traversal
	A. stack的top（）函数返回的是栈顶元素的副本，不是引用，所以在后序遍历的过程中一定要先退出栈，再压入！

20 Minimum Depth of Binary Tree
	A. 结合第17条，必须在检查当前节点的时候，进行节点处理（看是不是叶子节点），而不是想当然的在两次递归完成后才是叶子节点…………………………！！！！！！！！

21 Compare Version Numbers
	A. C++标准中因为数组不是一种类型，所以函数不能返回数组，三种处理方式：
		1）返回指向数组的指针
		2）返回结构体，把数组包裹在其中
		3）引用参数传递
	B. C++中用sstream库进行string与各种类型之间的安全转换！！

22 Search for a Range
	A. 二分查找，注意边界条件的判断！就是low == high的情况如何处理！！！

23 Convert Sorted Array to Binary Search Tree
	A. 递归构建平衡二叉树的一种思路！！
	B. 位运算符的优先级要低于算术运算符
	C. 一定养成良好的编程习惯：变量的初始化；本例中就是因为指针变量未初始化，导致RunTime Error

24 字符串拼接尽量用+,而不是append。

25 Majority Element
	A. 可以考虑其他实现方法：充分挖掘题目隐含关系，从而实现高效算法！！！！！！！

26 Count and Say
	A. 使用sstringstream时，注意清空问题：ss.str("") + ss.clear();

27 Sort List
	A. !!!指针变量也存在引用与否的问题，如果在递归中，是一局部变量，则返回时，就会释放，所以一定要注意定义返回值保存该过程中计算结果：
		int* cal(int *a) {
			int b;
			a = *b;
			return a;
		}

		void main() {

			int *a = new int;

			cal(a);


		}
	若a计算后的值，只有在该域内有效，若偏离该域，则要定义新的变量存储该值，此时a的值并没有改变。因为参数传递过程中，是将a的变量值拷贝到了形参！！！！但是若是在函数中改变变量所指的值，则val会更新，而地址值是不变的！
	B. 归并排序中，链表可以不用辅助空间，但是顺序表需要O(n)的辅助数组。
	C. 链表中如何寻找中点！！

28 Balanced Binary Tree
	A. 递归过程分析很重要，要考虑变量如何维护：返回到上层调用函数可以用引用参数，适用于本次调用的参数依赖于下层子问题的影响。

29 Jump Game II
	A. 静下心来，用case帮助思考找充分条件！！！How to solve it! 从问题出发！！不要考虑其他的：管他叫什么，反正就是这样子！！

30 Gas Station
	A. 注意细心查找隐藏关系：前面的不行，到此为止，都不行，所以可以O(n)
	B. 搞清楚关系本质才能快速代码化！！千万不能模棱两可，去找出内在联系，然后再代码化，不能猜！！

31 Flatten Binary Tree to Linked List
	A. 递归值的记录有两种方式：
		1) 引用传递
		2）递归函数的返回值
		影响是双向的，要看自己是从父子哪个角度看： 代码leftRe->right = tmp
		因为这两种方式，都在整个可见域内
	B. 注意低吗：return leftRe :当前层就要返回当前层的！！！

32 Scramble String
	A. 基本类型、声明符、修饰符
	B. new生成数组？！
	C. dp的本质就是子问题的记录功能，以至于能够不重复计算子问题！
	D. 看问题，一定要仔细分析，找到充分条件，否则事倍功半！注意子问题的划分，可以多求子问题，但不可以少求！问题复杂的时候，一定要拿case去找联系！

33 Climbing Stairs
	A. 记得从另一角度思考问题！！！！不同的角度可以建立不同的解决问题的模型！！！！

34 Sqrt(x)
	A. 牛顿迭代法！！！注意问题的抽象建模，可以从多个角度出发！！！
	B. 亦可以有二分法！！

35 Sum Root to Leaf Numbers
	A. 递归中需要记录所有上层影响的（回溯时需要用到当层的状态），传递赋值参数记录上层即可；若全局影响的可以定义引用变量！

36 Best Time to Buy and Sell Stock IV
	A. 动态规划主要是状态的表示及状态转移=====》建模！！

37 Binary Tree Preorder Traversal
	A. 设立哨兵可以给程序带来很大的便利！！！ stk.push(NULL);

38 Populating Next Right Pointers in Each Node
	A. 模型一定要在逻辑上描述清楚，要形式化，数据化，这样的模型才能迅速转化成代码！！避免模型模糊就开始code！！！
	B. 一定要从多个角度去寻找关系，建立模型！！！！

39 Populating Next Right Pointers in Each Node II
	A. 一定要清晰的找到关系，从问题出发，仔细推敲，才能找到高效的模型！！！

40 Largest Rectangle in Histogram
	A. 注意寻找关系，找到合适的思路就要动手去解决，不要害怕麻烦！注意用How to solve it去实际解决问题。遇到问题就要去找解决方案。例如本题中：O(n^2)的解法一般过不了，但是是不是可以找到有关剪枝方法，从而绕过某些大数据的检测；再者，如果实在过不了，那么只有从算法的角度去寻找复杂度降一级的高效算法，那么就是O(n)，这样的算法就是扫描一遍，那么如何抽象出模型，就要看自己如何去分析问题了，找到思路的关键点之后，要考虑如何转化实现，此时已经不是思路的问题，是自己coding能力的问题，不要因为coding的问题而让自己放弃一个很好的算法！本题中妙在栈存贮的都是下标，而不是高度！

41 Word Search
	A. 一定考虑好边界条件以及描述好解题模型，coding如果耗时就是因为边界考虑不清，模型还不清晰的时候就coding！
	B. 一定要注意训练如何快速的把思路转化成代码！！！如有模糊，就停下coding，先理清思路！！！

42 Unique Binary Search Trees II
	A. 递归法可以解决，但是要注意的是，递归的过程中首先解决的是子问题，所以，每当产生一个子树的时候，都会push到返回列表中，此时，其实子树的根并非是一个树的根！！！
	=> 递归求解的是子问题，若要求整个枚举的树，则要先先求出左右子树，然后再外侧一次生成根，否则还是子树！！

43 4Sum
	A. 算法分类：模拟、暴力（枚举、回溯、隐式图搜索）、DP; 而在暴力枚举中可以通过设计不同的枚举方案可以达到剪枝的目的，从而优化算法，提高效率！本题就是这样，通过借鉴快排思想，不单单是简单的枚举，通过限制条件，可以从目标出发，减掉无用的搜索，从而实现剪枝的目的，优化算法！！！！

44 Pascal's Triangle II
	A. 注意用纸笔找出规律而不是想当然的考虑。然后用程序逐步实现！！！！

45 Bitwise AND of Numbers Range
	A. 注意解决问题应该从意义出发而不是从形式出发，否则本末倒置，要找到问题的根本所在，找到问题最终要求的实质核心，然后依据此为出发点，解决问题：一定要深入理解问题，仔细从样例中找到问题的本质！！！！本题中问题的实质其实就是最高位有哪几位是相同的！

46 Repeated DNA Sequences
	A. 注意从理性角度分析问题，找到问题的核心本质，依据分类经验进行有效思考：本题中要求比对，那一种高效的方式就是hash处理，而hash处理中有两处比较重要：key的映射以及冲突处理，那就要自己设计一种映射方法使得题目得到解决，这就要依据具体题目进行具体分析！！！

47 Largest Number
	A. 类中的比较函数要是静态的！！

48 Dungeon Game
	A. olution1： TLE :枚举所有方案的答案，然后比较得出最终答案 =>看看能不能进行剪枝
	B. 动态规划方案：
// solution 2: WA，此方案是正向推，其实隐藏着trap:不存在最优子结构性质，所以算法本身是错误的，但是反过来，因为知道最后要达到的状态，可以从后往前推，得到族中答案！=> 注意问题的初始状态以及最终状态，若知道初始状态，可以从前往后，特别是如若知道最终状态，可以从后往前推。
//soulution 3:动态规划，从后往前推的过程，其实动态规划本质上就是记录了子结构的一种映射解决方案。
	C. 算法的优雅要考建模进行抽象化简，如本题中的可以直接用max（1，expression）来代替繁琐的if判断语句，这就需要自己要进行数式建模，然后依靠模型进行变换化简！！！

49 Fraction to Recurring Decimal
	A. 用unordered_map来映射可以在基本不损失速度的前提下，节省空间，如果自己开辟数组去标记，很可能申请不到那么大的空间！！！！
	B. 判断两个数是否是异号！！！

50 Single Number II
	A. 注意拆分元素，在找不到合适的关系的时候，看看问题处理的元素是不是可以从其更小的组成元素上入手解决，本题就是考虑了题目所求约束下，在其组成位上的表现规律，进而得到该问题的求解！
	B. 在想法转化成code的过程中，注意关系表达的经验积累！！！

51 Palindrome Partitioning
	A. 注意递归中的回溯问题，问题的answer要随之回溯的变换而后退，这时候相应的回退answer就可以，不用考虑解答树中每一条路径都要维护一个解答！！（递归之后pop_back())

52 Pow(x, n)
	A. 求幂，可以二分法，每次计算原先的二倍！！！

53 Maximum Gap
	A. 桶排序， 鸽巢原理的应用！！！
	B. *max_element(), *min_element() STL算法！！

54 Reverse Nodes in k-Group
	A. 堆链表进行插入、逆转等操作的时候，最好申请一个头结点！！！统一空表和飞空表的实现！！！
	B. 一定注意力集中，权利解决问题，注意平复情绪！！沉稳答题！！

